\section{Circuit Encoding Schemes}

We investigate here quantum pendants to the function encoding schemes used in \tnreason{}{}.

\begin{itemize}
    \item Pendant for Coordinate Encoding in \tnreason{}: Amplitude Encoding, storing the function value in the amplitude of an ancilla qubit.
    This is realized by an \textbf{\ActivationCircuit{}}.
    \item Pendant for Basis Encoding in \tnreason{}: \textbf{\ComputationCircuit{}}, with composition by contraction property.
\end{itemize}

Both are defined using controlled single qubit gates (see Sections 4.2-3 in [Nielsen, Chuang]) with ancilla qubits being the target qubits. % where the incoming qubit variable is $\avariableof{\insymbol}$ and the outgoing $\avariableof{\outsymbol}$.

\subsection{\ActivationCircuit{}}


%% Angle preparing
We define the angle preparing function on $p\in[0,1]$ by
\begin{align*}
    h(p) = 2 \cdot \mathrm{cos}^{-1}\left(\sqrt{1-p}\right) \, .
\end{align*}
For any $p\in[0,1]$ we then have
\begin{align*}
    \contractionof{\onehotmapofat{0}{\avariableof{\insymbol}},\yrotationofat{h(p)}{\avariableof{\insymbol},\avariableof{\outsymbol}}}{\avariableof{\outsymbol}}
    = \begin{bmatrix}
          \sqrt{1-p} \\
          \sqrt{p}
    \end{bmatrix} \, .
\end{align*}

\begin{definition}[\ActivationCircuit{}]
    Given a function
    \begin{align*}
        \exfunction : \bigtimes_{\selindexin} [2] \rightarrow [0,1]
    \end{align*}
    its \activationCircuit{} is the controlled unitary
    $\qcaencodingofat{\hypercore}{\avariableof{\insymbol},\avariableof{\outsymbol},\headvariableof{[\seldim]}}$ defined as
    \begin{align*}
        \qcaencodingofat{\hypercore}{\avariableof{\insymbol},\avariableof{\outsymbol},\headvariableof{[\seldim]}}
        = \sum_{\headindexof{[\seldim]}} \onehotmapofat{\headindexof{[\seldim]}}{\headvariableof{[\seldim]}}
        %\otimes \onehotmapofat{\headindexof{[\seldim]}}{\headvariableof{\insymbol,[\seldim]}}
        \otimes \yrotationofat{h(\exfunctionat{\headindexof{[\seldim]}})}{\avariableof{\insymbol},\avariableof{\outsymbol}} \, .
    \end{align*}
\end{definition}

%% Drop the in and out
We will ease our notation by dropping the $\insymbol$ and $\outsymbol$ labels to the control variables.
This amounts to understanding the Dirac delta tensors in \activationCircuits{} as hyperedges.
Along that picture the quantum circuit is a tensor network on hyperedges instead of edges.


When we have a probability tensor, its \activationCircuit{} be prepared, since all values are in $[0,1]$.
Note that for rejection sampling, only the quotients of the values are important, we can therefore scale the value by a scalar such that the mode is $1$.

Tensors $\hypercoreat{\headvariables}$ with non-negative coordinates can be encoded after dividing them by their maximum, that is the \activationCircuit{} of the function
\begin{align*}
    \exfunctionat{\headindexof{[\seldim]}} = \frac{\hypercoreat{\headvariables=\headindexof{[\seldim]}}}{\max_{\secheadindexof{[\seldim]}} \hypercoreat{\headvariables=\secheadindexof{[\seldim]}}}
\end{align*}
When the maximum of the tensor is not known, it can be replaced by an upper bound (reducing the acceptance rate of the rejection sampling).

\subsubsection{Encoding of directed tensors}

Following the schemes in \cite{low_quantum_2014}, we can prepare the acyclic networks of directed and non-negative tensors by a sequence of controlled rotations.
Directed and non-negative tensors correspond with conditional probability distributions and acyclic networks are Bayesian Networks.
We prepare them by \activationCircuit{}s of functions (see \figref{fig:cpdEncoding})
\begin{align*}
    \catindexof{\parentsof{\catenumerator}} \rightarrow \condprobat{\catvariableof{\catenumerator}=1}{\indexedcatvariableof{\parentsof{\catenumerator}}} \, .
\end{align*}

In this way, Bayesian Networks can be prepared as quantum circuits, where each conditional probability distribution is prepared by an \activationCircuit{}.

\begin{theorem}[Low et al.]
    Any Bayesian Network of variables $\shortcatvariables$, where the enumeration by $[\atomorder]$ respects the partial order by child-parent relations, can be prepared as a quantum circuit by concatenating the \activationCircuit{}s
    \begin{align*}
        \qcaencodingofat{
            \condprobat{\catvariableof{\catenumerator}=1}{\catvariableof{\parentsof{\catenumerator}}}
        }{\catvariableof{\catenumerator,\insymbol},\catvariableof{\catenumerator},\catvariableof{\parentsof{\catenumerator}},\catvariableof{\parentsof{\catenumerator}}}
    \end{align*}
    for $\atomenumeratorin$ and acting on the initial state $\bigotimes_{\atomenumeratorin}\onehotmapofat{0}{\catvariableof{\catenumerator,\insymbol}}$ .
\end{theorem}


%To this end, one iterates over the states of the incoming variables, and performs a controlled rotation on the outgoing variable, where the angle is given by the value of the tensor at the incoming state.
%This generalizes the basis encoding scheme, which demands boolean tensors.

\begin{figure}
    \begin{center}
        \input{./tikz_pics/directed_to_circuit.tex}
    \end{center}
    \caption{
        Representation of directed and positive tensor by a controlled rotation.
        a) Conditional probability tensor $\condprobat{\catvariableof{\catenumerator}}{\catvariableof{\parentsof{\catenumerator}}}$ being a tensor in a Bayesian Network.
        b) Circuit Encoding as a controlled rotation, which is the \ActivationCircuit{} of the tensor $\condprobat{\catvariableof{\catenumerator}=1}{\catvariableof{\parentsof{\catenumerator}}}$.
    }\label{fig:cpdEncoding}
\end{figure}

\subsection{\ComputationCircuits{}}

We here suggest a quantum pendant to basis encodings (see Chapter Basis Calculus), which has the decomposition by contraction property.

\begin{definition}[\ComputationCircuit{}]
    Given a boolean function $\exfunction:\atomstates\rightarrow[2]$ the \computationCircuit{} is the unitary tensor
    \begin{align*}
        \qcbencodingofat{\exfunction}{\headvariableof{\insymbol,\exfunction},\headvariableof{\outsymbol,\exfunction},\shortcatvariables}
        &\quad=
        \sum_{\shortcatindicesin\wcols\exfunctionat{\shortcatindices}=1}
        \paulixat{\headvariableof{\insymbol,\exfunction},\headvariableof{\outsymbol,\exfunction}} \otimes
        \onehotmapofat{\shortcatindices}{\shortcatvariables} \\ % \otimes \onehotmapofat{\shortcatindices}{\catvariableof{\outsymbol,[\atomorder]}} \\
        & \quad \quad \quad +
        \sum_{\shortcatindicesin\wcols\exfunctionat{\shortcatindices}=0}
        \identityat{\headvariableof{\insymbol,\exfunction},\headvariableof{\outsymbol,\exfunction}} \otimes
        \onehotmapofat{\shortcatindices}{\shortcatvariables} \, . % \otimes \onehotmapofat{\shortcatindices}{\catvariableof{\outsymbol,[\atomorder]}}
    \end{align*}
\end{definition}

Notice, that $U^{\lnot} = \mathrm{CNOT}$, which is obvious from $\onesat{\headvariableof{\insymbol},\headvariableof{\outsymbol}} - \identityat{\headvariableof{\insymbol},\headvariableof{\outsymbol}}$ being the Pauli-X gate (not to be confused with $X$ denoting distributed variables here).
The \computationCircuit{} is therefore a generalized controlled $\mathrm{NOT}$ gate, where the control is by a boolean function.

Functions with multiple output variables, i.e. $\exfunction:\atomstates\rightarrow\bigtimes_{\selindexin}[2]$, can be encoded image coordinate wise as a concatenation of the respective circuits.

\subsubsection{Composition by Contraction - Exploiting \DecompositionSparsity{}}

The decomposition by contraction property of basis encodings is now a composition of circuits property, as stated in the next lemma.

\begin{lemma}
    We have for functions $\exfunction:\atomstates\rightarrow\bigtimes_{\selindexin}[2]$, $\secexfunction:\bigtimes_{\selindexin}[2]\rightarrow\bigtimes_{s\in[r]}[2]$ (see \figref{fig:qcbencodingDecomposition})
    \begin{align*}
        \qcbencodingofat{\secexfunction\circ\exfunction}{\headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction},\catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]}}
        = \breakablecontractionof{
            &\onehotmapofat{0}{\headvariableof{\insymbol,\exfunction}},\\
            &\qcbencodingofat{\exfunction}{\headvariableof{\insymbol,\exfunction},\headvariableof{\outsymbol,\exfunction},\catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]}},\\
            &\qcbencodingofat{\secexfunction}{\headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\exfunction},\headvariableof{\outsymbol,\exfunction}}
        }{
            \headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction},\catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]}
        } \, .
    \end{align*}
\end{lemma}

When having a syntactical decomposition of a propositional formula, we can iteratively apply the \computationCircuit{} decomposition theorem and prepare each connective by a circuit.
We can decompose any propositional formula into logical connectives and prepare to each a modulus 2 circuit implementation.
This works, when the target qubit of one connective is used as a value qubit of another.

\begin{figure}
    \begin{center}
        \input{./tikz_pics/decomposition_sparsity.tex}
    \end{center}
    \caption{
        Exploitaition of \DecompositionSparsity{} in \computationCircuit{}s.
    }\label{fig:qcbencodingDecomposition}
\end{figure}


%    \begin{lemma}
%        We have for functions $\exfunction:\atomstates\rightarrow\bigtimes_{\selindexin}[2]$, $\secexfunction:\bigtimes_{\selindexin}[2]\rightarrow\bigtimes_{s\in[r]}[2]$
%        \begin{align*}
%            \qcbencodingofat{\secexfunction\circ\exfunction}{\catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]},\headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction}}
%            = \breakablecontractionof{
%                &\onehotmapofat{0}{\headvariableof{\insymbol,\exfunction}},\\
%                &\qcbencodingofat{\exfunction}{\catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]},\headvariableof{\insymbol,\exfunction},\headvariableof{\outsymbol,\exfunction}},\\
%                &\qcbencodingofat{\secexfunction}{\headvariableof{\outsymbol,\exfunction},\headvariableof{\outsymbol,\mathrm{aux}},\headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction}}
%            }{
%                \catvariableof{\insymbol,[\atomorder]},\catvariableof{\outsymbol,[\atomorder]},\headvariableof{\insymbol,\secexfunction\circ\exfunction},\headvariableof{\outsymbol,\secexfunction\circ\exfunction}
%            } \, .
%        \end{align*}
%    \end{lemma}

Note, that the variables $\headvariableof{\outsymbol,\mathrm{aux}}$ are auxiliar and not left open in the contraction.
This amounts to not measuring them in a computational basis measurement.

\subsubsection{Construction for mod2-basis+ CP decompositions - Exploiting \PolynomialSparsity{}}

Concatenating two \computationCircuit{}s, which have the same head qubit, is the \computationCircuit{} of their mod2 sum.

A basis+ elementary function can be encoded by a single controlled NOT operation with auxiliary X qubits.

This motivates the mod2-basis+ CP decomposition of tensors, which is exactly the decomposition of boolean polynomials into monomials.
Each monomial is called a terms (products of x or (1-x) factors), and minterms in case that all variables appear.

\begin{definition}
    Given a boolean tensor $\hypercore$, a mod2-basis+ CP decomposition is a collection $\sliceset$ of tuples $(\variableset,\catindexof{\variableset})$ with such that for any $\shortcatindicesin$
    \begin{align*}
        \hypercoreat{\indexedshortcatvariables}
        = \bigoplus_{(\variableset,\catindexof{\variableset})\in\sliceset} \contractionof{\onehotmapofat{\catindexof{\variableset}}{\catvariableof{\variableset}}}{\indexedshortcatvariables} \, .
    \end{align*}
\end{definition}

Using that basis CP decompositions are a special case of basis+ CP decompositions, we get the following rank bound.

\begin{lemma}
    The mod2-basis+ CP rank is bounded by the basis CP rank.
\end{lemma}
\begin{proof}
    Use $\variableset=[\atomorder]$, and $\catindexof{\variableset}$ to each supported state.
    Then the mod2-sum is a usual sum and the basis CP decomposition is also a mod2-basis+ CP decomposition.
\end{proof}

This shows in particular, that any propositional formula can be represented by a mod2-basis+ CP decomposition.

\begin{lemma}
    The \computationCircuit{} to a boolean tensor $\hypercore$ with a mod2-basis+ CP decomposition $\sliceset$ obeys
    \begin{align*}
        &\qcbencodingofat{\hypercore}{
            \headvariableof{\hypercore,\insymbol},\headvariableof{\hypercore,\outsymbol},\catvariableof{[\atomorder],\insymbol},\catvariableof{[\atomorder],\insymbol}
        } \\
        & \quad =
        \breakablecontractionof{
            \{\identityat{\headvariableof{\hypercore,\insymbol},\headvariableof{0}},\identityat{\headvariableof{\hypercore,\outsymbol},\headvariableof{\cardof{\sliceset}-1}}\} \cup
            \{\qcbencodingofat{\onehotmapof{\catindexof{\variableset}}}{
                \headvariableof{\decindex}, \headvariableof{\decindex+1},
                \catvariableof{\variableset,\insymbol},\catvariableof{\variableset,\outsymbol}} \wcols (\variableset,\catindexof{\variableset})\in\sliceset\}
        }{\headvariableof{\hypercore,\insymbol},\headvariableof{\hypercore,\outsymbol},\catvariableof{[\atomorder],\insymbol},\catvariableof{[\atomorder],\outsymbol}}
    \end{align*}
    where $\decindex\in[\cardof{\sliceset}]$ enumerates the tuples in $\sliceset$.
\end{lemma}

Each \computationCircuit{} to each boolean monomial can be prepared by a multiple-controlled $\paulixsymbol$ gate and further pairs of $\paulixsymbol$ gates preparing the control state, see \figref{fig:qcbencodingPolynomial}. %where the control qubits are the affected variables and the target qubit is the value qubit.
When we sum monomials wrt modulus 2 calculus, then the preparation is a sequence of such circuits.
In such way, we can prepare the \computationCircuit{} to any propositional formula.
This encoding strategy exploits a modified (by mod2 calculus) \polynomialSparsity{}.

\begin{figure}
    \begin{center}
        \input{./tikz_pics/polynomial_sparsity.tex}
    \end{center}
    \caption{
        Exploitaition of \PolynomialSparsity{} in \computationCircuit{}s.
        Here, we use the typical denotation of a muliple-controlled CNOT gate, which control symbols do not indicate Dirac tensors.
    }\label{fig:qcbencodingPolynomial}
\end{figure}

\subsubsection{Preparation by fine and coarse structure}

Having a mod2-basis+ CP decomposition of rank $r$ to a connective, we need $r$ controlled NOT gates to prepare the basis encoding.
Given a syntactical decomposition of a boolean statistics, we prepare the basis encoding as a circuit with:
\begin{itemize}
    \item \textbf{Fine Structure:} Represent each logical connective based on its mod2-basis+ CP decomposition, as a concatenation of \computationCircuit{}s with the same variables.
    \item \textbf{Coarse Structure:} Arrange the logical connective representing circuits according to the syntactical hypergraph, where parent head variables appear as distributed variables at their children.
\end{itemize}